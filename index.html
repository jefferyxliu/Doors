<!doctype html>
<html lang="en">
  <title>Doors</title>
  <head>
  <meta name="viewport" content="height=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
      canvas {
        border: 1pt solid black;
        border-radius: 8px;
        background-color: grey;
      }

      #canvas2 {
        background-color: black;
      }

      #textbox {
        overflow: scroll;
        border-radius: 8px;
        background-image: linear-gradient(to right, rgba(0,0,0,0.5), rgba(0,0,0,0)); 
        font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
        color: white;
        position: absolute;
        height: 80px;
        max-height: 80px;
        padding-left: 5px;
        padding-bottom: 5px;
        margin-left: 1px;
        margin-bottom: 5px;
        bottom: 0;
      }

      .hide {
        display: none;
        background-color: purple;
      }

      #gridDisplay {
        border: 1pt solid black;
        border-radius: 8px;
        padding: 5px;
        display: grid;
        grid-template-rows: 2, 2;
        grid-auto-columns: min-content;
        width: min-content;
        gap: 5px;
      }
      
      #StatBox {
        overflow: scroll;
        width: 200px;
      }
      #gridDisplay2 {
        border: 1pt solid black;
        border-radius: 8px;
        padding: 5px;
        display: grid;
        grid-template-rows: 2, 2;
        grid-auto-columns: min-content;
        width: min-content;
        gap: 5px;
        bottom: 0;
        position: fixed;
      }
      #gridButton {
        display: grid;
        grid-template-rows: 4, 4;
        grid-auto-columns: 80px;
        grid-auto-rows: 0px 38px 38px;
        width: min-content;
      }
      #gridButton2 {
        display: grid;
        grid-template-rows: 3, 3;
        grid-auto-columns: 38px;
        grid-auto-rows: 38px;
        width: min-content;
        justify-self: center;
      }
      input {
        font-size: 12px;
      }
  </style>
  </head>
<body>
<div class="hide">
    <canvas id="canvas"></canvas>
</div>
<div>
    <div id="gridDisplay">
        <div style="grid-row: 1; grid-column: 1; position: relative;">
            <canvas id="canvas2" width="device-width" height="device-width"></canvas>
            <div id="textbox"></div>
        </div>
        <div style="grid-row: 1; grid-column: 2;" id = "StatBox"></div>
        
    </div>
    <div id="gridDisplay2">
        <div id="gridButton">
            <input type="button" id="KeyZ" value="Drop (Z)" style="grid-row: 2; grid-column: 1;"></input>
            <input type="button" id="KeyX" value="Pick Up (X)" style="grid-row: 2; grid-column: 2;"></input>
            <input type="button" id="KeyC" value="Use Item (C)" style="grid-row: 2; grid-column: 3;"></input>
            <input type="button" id="KeyV" value="Wait (V)" style="grid-row: 2; grid-column: 4;"></input>
            <input type="button" id="Space" value="Attack (Space)" style="grid-row: 3; grid-column: 1 / 5;"></input>
        </div>
        <div id="gridButton2">
            <input type="button" id="ArrowUp" value="&uarr;" style="grid-row: 1; grid-column: 2;"></input>
            <input type="button" id="ArrowDown" value="&darr;" style="grid-row: 2; grid-column: 2;"></input>
            <input type="button" id="ArrowLeft" value="&larr;" style="grid-row: 2; grid-column: 1;"></input>
            <input type="button" id="ArrowRight" value="&rarr;" style="grid-row: 2; grid-column: 3;"></input>
        </div>
    </div>
</div>

</div>
<script src = "species.js"></script>
<script src = "moves.js"></script>
<script src = "items.js">//must load moves first (before TMs)</script> 
<script src = "statusEffects.js"></script>
<script>
    function csvToArray(s) {
        return `[[${s.replaceAll('\n', '],[')}]]`;
    }

    let idGenerator = 0;
    function generateNewID() {
        idGenerator++;
        return idGenerator;
    }
    function deepCopy(object) {
        return JSON.parse(JSON.stringify(object));
    }

    const textbox = document.getElementById('textbox');
    const canvas = document.getElementById('canvas');
    const canvas2 = document.getElementById('canvas2');
    const h = 11;
    const w = 11;
    canvas.width = 24 * w;
    canvas.height = 24 * h;
    const ctx = canvas.getContext('2d');
    const ctx2 = canvas2.getContext('2d');


    function print(s) {
        console.log(s);
        textbox.innerText += s + '\n';
        textbox.scroll({
            top: textbox.scrollHeight,
            left: 0,
            behavior: "smooth"
        });
    }

    function resize() {
        const statBox = document.getElementById('StatBox');
        const arrowButtons = document.getElementById('gridButton2');
        let verticalMargin = 120;
        let horizontalMargin = 230;
        if (window.innerWidth > 455) {
            arrowButtons.style.gridRow = 1;
            arrowButtons.style.gridColumn = 2;
        } else {
            arrowButtons.style.gridRow = 2;
            arrowButtons.style.gridColumn = 1;
            verticalMargin += 80;
        }
        if (window.innerWidth > window.innerHeight) {
            statBox.style.gridRow = 1;
            statBox.style.gridColumn = 2;
            const m = Math.min(window.innerHeight - verticalMargin, window.innerWidth - horizontalMargin);
            canvas2.width = m;
            canvas2.height = m;
            textbox.clientWidth = m - 10;
            statBox.style.height = `${m}px`;
        } else {
            statBox.style.gridRow = 2;
            statBox.style.gridColumn = 1;
            verticalMargin += 58;
            horizontalMargin -= 200;
            const m = Math.min(window.innerHeight - verticalMargin, window.innerWidth - horizontalMargin);
            canvas2.width = m;
            canvas2.height = m;
            textbox.clientWidth = m - 10;
            statBox.style.height = `${window.innerHeight - m - verticalMargin + 58}px`;
        }
        if (game.loaded) {
            game.drawEverything(game.you.position);
        }
    }

    window.onresize = resize;

    function randomElement(array) {
        return array[Math.floor(Math.random() * array.length)];
    }

    function coordsEq(coords1, coords2) {
        return coords1.x == coords2.x && coords1.y == coords2.y;
    }

    function addCoords(coords1, coords2) {
        return {
            x: coords1.x + coords2.x,
            y: coords1.y + coords2.y
        }
    }

    function subCoords(coords1, coords2) {
        return {
            x: coords1.x - coords2.x,
            y: coords1.y - coords2.y
        }
    }

    function rotate(direction, coord) {
        const cos = {
            'ArrowRight': 1,
            'ArrowUp': 0,
            'ArrowLeft': -1,
            'ArrowDown': 0
        }
        const sin = {
            'ArrowRight': 0,
            'ArrowUp': -1,
            'ArrowLeft': 0,
            'ArrowDown': 1
        }
        return {
            x: cos[direction] * coord.x - sin[direction] * coord.y,
            y: sin[direction] * coord.x + cos[direction] * coord.y
        }
    }

    function approxDir(coords) {
        return ['ArrowRight','ArrowDown','ArrowLeft','ArrowUp'][(Math.round(2 * Math.atan2(coords.y, coords.x) / Math.PI + 1.5) + 2) % 4];
    }

    function dist(coords1, coords2) {
        //taxicab distance
        return Math.abs(coords1.x - coords2.x) + Math.abs(coords1.y - coords2.y);
    }
    
    function dist1(coords1, coords2) {
        //sup distance
        return Math.max(Math.abs(coords1.x - coords2.x), Math.abs(coords1.y - coords2.y));
    }

    function screenCoords(coords) {
        return {
            x: (coords.x - game.you.position.x + Math.floor(w/2)) * Math.floor(canvas.width / w),
            y: (coords.y - game.you.position.y + Math.floor(h/2)) * Math.floor(canvas.height / h)
        }
    }

    class Entity {
        constructor(data) {
            this.secretID = generateNewID();
            this.name = data.nickname;
            this.stat = data.stat;
            this.HP = this.stat.maxHP;
            this.types = this.stat.types;
            this.actionCounter = 0;

            this.position = data.position;
            this.startPosition = data.position;

            this.direction = data.options.direction;
            this.color = this.stat.color;
            this.team = data.options.team;
            this.control = data.options.control;

            this.moveset = data.options.moveset;
            this.item = data.options.item;
            this.statusEffects = {};

            this.solidTiles = this.getSolidTiles();

            this.sprite = data.stat.sprite;
            this.size = data.stat.size;

            this.loaded = false;
            if (this.sprite) {
                this.image = new Image(this.size, this.size);
                this.image.src = `sprites/${this.sprite}.png`;
                this.image.onload = () => {
                    this.loaded = true;
                    this.generateHPBar();
                };
            }
        }

        generateHPBar() {
            document.getElementById('StatBox').innerHTML += 
                `<div id = "${this.secretID}-Box" style="display: none; border: 1pt solid black; border-radius: 8px; padding: 5px;">\
                    <div id = "${this.secretID}"></div>\
                    <canvas id = "${this.secretID}-Sprite" height="24px" width="24px" style="border: none; background-color: transparent;"></canvas>\
                    <canvas id = "${this.secretID}-HP" height="15" width="100"></canvas>\
                </div>`;
        }

        isAlive() {
            return this.HP > 0;
        }

        getSolidTiles() {
            let t = [];
            const tileType = {
                'floor' : [0,1,2,3,4], //all
                'hidden' : [5], //player
                'wall' : [6,7,8,9,10], //none
                'enemy' : [11], //only enemy cross
                'air' : [12,13], //flying types
                'water' : [14,15], //flying and water types
                'lava' : [17,18], //flying and fire types
            }

            t = t.concat(tileType['wall']);
            if (!this.team == 0) {
                t = t.concat(tileType['hidden']);
            }
            if (this.team == 0) {
                t = t.concat(tileType['enemy']);
            }
            if (!this.types.includes('flying')) {
                t = t.concat(tileType['air']);
            }
            if (!this.types.includes('water')) {
                t = t.concat(tileType['water']);
            }
            if (!this.types.includes('fire')) {
                t = t.concat(tileType['lava']);
            }
            return t;
        }

        getItem() {
            return itemList[this.item];
        }

        wait() {
            this.applyCooldown();
            //print(`${this.name} is waiting...`);
            if (this.stat.maxHP > this.HP) {
                print('');
                print(`${this.name} is resting a little`);
                this.heal(2);
            }
            
            if (this.control) {
                game.map.warp(this.position);
            }
        }

        changeStatStage(stat, addTurns = 10) {
            let newTurns = addTurns;
            if (Object.hasOwn(this.statusEffects, `${stat}Up`)) {
                newTurns += this.statusEffects[`${stat}Up`];
            }
            if (Object.hasOwn(this.statusEffects, `${stat}Down`)) {
                newTurns -= this.statusEffects[`${stat}Down`];
            }
            delete this.statusEffects[`${stat}Up`];
            delete this.statusEffects[`${stat}Down`];
            if (newTurns > 0) {
                this.statusEffects[`${stat}Up`] = newTurns;
            }
            if (newTurns < 0) {
                this.statusEffects[`${stat}Down`] = -newTurns;
            }

/*             const i = this.statusEffects.findIndex((status)=>{return status.name == `${stat}Up`});
            const j = this.statusEffects.findIndex((status)=>{return status.name == `${stat}Down`});
            let newTurns = addTurns;
            if (i != -1) {
                newTurns += this.statusEffects[i].turns;
            }
            if (j != -1) {
                newTurns -= this.statusEffects[j].turns;
            }
            this.statusEffects = this.statusEffects.filter((status)=>{return !(status.name == `${stat}Up` || status.name == `${stat}Down`)});
            if (newTurns > 0) {
                this.statusEffects.push({name:`${stat}Up`, turns: newTurns});
            }
            if (newTurns < 0) {
                this.statusEffects.push({name:`${stat}Down`, turns: -newTurns});
            } */
        }

        inflictStatus(status, turns) {
            const message = {
                    'burn': `${this.name} was burned.`, 
                    'frostbite': `${this.name} was frostbitten.`,
                    'paralysis': `${this.name} was paralyzed.`,
                    'sleep': `${this.name} fell asleep.`,
                    'poison': `${this.name} was poisoned.`,
            }

            if (status == 'burn' && this.types.includes('fire')) {
                return false;
            }
            if (status == 'paralysis' && this.types.includes('electric')) {
                return false;
            }
            if (status == 'poison' && (this.types.includes('poison') || this.types.includes('steel'))) {
                return false;
            }
            const volatile = ['burn', 'frostbite', 'paralysis', 'sleep', 'poison'];
            if (volatile.includes(status)) {
                for (const oldStatus of volatile) {
                    delete this.statusEffects[oldStatus];
                }
                this.statusEffects[status] = turns;

                print(message[status]);
            }
            return true;
        }

        modifyStat(stat, baseValue) {
            let value = baseValue;
            if (this.item != 'none') {
                const item = this.getItem();
                if (Object.hasOwn(item, `${stat}StatModifier`)) {
                    value *= item[`${stat}StatModifier`];
                };
            }
            for (const status in this.statusEffects) {
                const st = statusList[status];
                if (Object.hasOwn(st, `${stat}StatModifier`)) {
                    value *= st[`${stat}StatModifier`];
                };
            }
/*             for (const status of this.statusEffects) {
                const st = statusList[status.name];
                if (Object.hasOwn(st, `${stat}StatModifier`)) {
                    value *= st[`${stat}StatModifier`];
                };
            } */
            return Math.max(Math.floor(value), 1);
        }

        applyCooldown() {
            this.actionCounter += this.modifyStat('cooldown', this.stat.cooldown);
        }

        move(code) {
            if (code != this.direction) {
                this.direction = code;
                return false;
            }

            const target = this.getTarget();
            //print(target);
            if (!target) {
                this.position = addCoords(this.position, game.controls[code]);
                this.applyCooldown();
                //print(`${this.name} moved.`);
                return true;
            }
            
            if (target == 'wall') {
                this.wait();
                return false;
            }

            if (target.team != this.team || !this.control) {
                this.wait();
                return false;
            }

            this.switch(target);
            this.applyCooldown();
            return false;
        }

        switch(target) {
            const p = target.position;
            target.position = this.position;
            this.position = p;
        }

        useMove(n = 0) {
            print('');
            if (onUseMove(this, moveList[this.moveset[n % this.moveset.length]], {})) {
                game.moveUsed = {user: this, move: moveList[this.moveset[n % this.moveset.length]]};
            }
        }

        learnMove(moveName) {
            if (this.moveset.includes(moveName)) {
                print(`${this.name} already knows ${moveList[moveName].name}.`);
                return false;
            }
            this.moveset.push(moveName);
            if (this.moveset.length <= 4) {
                print(`${this.name} learned ${moveList[moveName].name}.`);
                return true;
            }
            let n;
            while (!['0','1','2','3','4'].includes(n)) {
                n = prompt(`${this.name} can't learn more than 4 moves. Select a move to delete (0,1,2,3,4): \n ${this.moveset}`);
            }
            print(`${this.name} learned ${moveList[moveName].name}.`);
            print(`${this.name} forgot ${moveList[this.moveset[JSON.parse(n)]].name}.`);
            this.moveset.splice(JSON.parse(n), 1);
            return true;
        }

        getTarget() {
            const fr = addCoords(this.position, game.controls[this.direction]);
            let st = this.solidTiles;
            
            if (this.item != 'none') {
                const item = this.getItem();
                if (Object.hasOwn(item, `onModifySolidTiles`)) {
                    st = item.onModifySolidTiles(st);
                };
            }
            //print(st);
            if (game.map.isWall(fr, st)) {
                return 'wall';
            }
            
            const s = game.spriteList.filter((sprite) => 
                coordsEq(sprite.position, fr) && sprite.isAlive()
            );
            if (s.length == 0) {
                return false;
            }
            return s[0];
        }

        getTargetSprites() {
            const fr = addCoords(this.position, game.controls[this.direction]);
            return game.spriteList.filter((sprite) => 
                coordsEq(sprite.position, fr) && sprite.isAlive()
            );
        }

        getAdjacentSprites() {
            return game.spriteList.filter((sprite) => 
                dist(sprite.position, this.position) == 1 && sprite.isAlive()
            );
        }

        getNearbySprites(n) {
            return game.spriteList.filter((sprite) => {
                const d = dist(sprite.position, this.position);
                return d <= n && d > 0 && sprite.isAlive();
            });
        }

        getFrontSprites(tilePattern) {
            return game.spriteList.filter((sprite) => {
                return tilePattern.some((tile) => {
                    return coordsEq(sprite.position, addCoords(this.position, rotate(this.direction, tile)))
                }) && sprite.isAlive();
            });
        }

        pickUpItem() {
            if (this.isAlive() && this.item == 'none') {
                this.item = game.map.getItem(this.position);
                print(`${this.name} picked up ${itemList[this.item].name}`);
            }
        }

        dropItem() {
            if (this.item == 'none') {
                return false;
            }
            game.map.spawnItem(this.item, this.position);
            print(`${this.name} dropped ${itemList[this.item].name}`);
            this.item = 'none';
            return true;
        }

        useItem() {
            if (this.isAlive() && this.item != 'none') {
                print(`${this.name} used ${itemList[this.item].name}`);
                itemList[this.item].onUse(this);
            } else {
                this.wait();
            }
        }

        heal(amount) {
            if (!this.isAlive()) {
                return false;
            }
            if (this.HP >= this.stat.maxHP) {
                return false;
            }
            const healAmount = Math.min(amount, this.stat.maxHP - this.HP)
            this.HP += healAmount;
            print(`> ${this.name} restored ${healAmount} HP.`);
            return true;
        }

        damage(amount) {
            if (!this.isAlive()) {
                return false;
            }
            this.HP = Math.max(0, this.HP - amount);
            print(`> ${this.name} took ${amount} damage.`);
            return true;
        }

        endTurn() {
            if (this.item != 'none') {
                const it = itemList[this.item];
                if (Object.hasOwn(it, 'onTurnEnd')) {
                    it.onTurnEnd(this);
                }
            }
            for (const status in this.statusEffects) {
                const st = statusList[status];
                if (Object.hasOwn(st, 'onTurnEnd')) {
                    st.onTurnEnd(this);
                }
                this.statusEffects[status]--;
                if (this.statusEffects[status] == 0) {
                    delete this.statusEffects[status];
                }
            }
            /* this.statusEffects = this.statusEffects.filter((status)=>{return status.turns > 0}); */
        }

        printTo(hidden = false) {
            if (!this.loaded) {
                return false;
            }
            document.getElementById(`${this.secretID}-Sprite`).getContext('2d').drawImage(this.image, this.size * 2, 0, this.size, this.size, 0, 0, 24, 24);
            this.nameBox = document.getElementById(`${this.secretID}-Box`);
            this.nameLabel = document.getElementById(this.secretID);
            this.HPBar = document.getElementById(`${this.secretID}-HP`);
            this.HPBarCtx = this.HPBar.getContext('2d');
            let s = `${this.name}`;
            if (this.isAlive()) {
                //s += ` (Next Turn: ${this.actionCounter})`;        
            }
            if (this.item != 'none') {
                s += ` : ${this.getItem().name}`
            }
            this.nameLabel.innerHTML = s;
            const percent = Math.floor(100 * this.HP / this.stat.maxHP);
            this.HPBarCtx.clearRect(0, 0, 100, 15);
            this.HPBarCtx.fillStyle = ['red','yellow','green'][0 + (percent >= 20) + (percent >= 50)];
            this.HPBarCtx.fillRect(0, 0, percent, 15);
            this.HPBarCtx.fillStyle = 'black';
            this.HPBarCtx.font = "bold 14px Arial";
            this.HPBarCtx.fillText(`${this.HP}/${this.stat.maxHP}`, 5, 13);
            if (hidden) {
                this.nameBox.style.display = 'none';
            } else {
                this.nameBox.style.display = 'block';
            }
        }

        draw() {
            const coords = screenCoords(this.position);
            if (this.sprite && this.loaded) {
                ctx.drawImage(this.image, this.size * game.arrowNumber[this.direction], 0, this.size, this.size, coords.x - Math.floor(this.size/2) + 12, coords.y - this.size + 24, this.size, this.size);
            } 
/*             else {
                ctx.fillStyle = this.color;
                ctx.fillRect(coords.x, coords.y, Math.floor(canvas.width / w), Math.floor(canvas.height / h));
            } */
        }

        turnToward(position) {
            this.direction = approxDir(subCoords(position, this.position));
        }

        smartGetDistance(targetPosition) {
            const distances = {
                'ArrowRight': Infinity,
                'ArrowLeft': Infinity,
                'ArrowUp': Infinity,
                'ArrowDown': Infinity,
            };
            for (const direction in distances) {
                const fr = addCoords(this.position, game.controls[direction]);
                if (!game.map.isWall(fr, this.solidTiles)) {
                    distances[direction] = dist(fr, targetPosition);
                }
            }
            const d = Object.values(distances);
            d.push(dist(this.position, targetPosition));
            const m = Math.min(...d);
            return ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'].filter((direction) => distances[direction] == m);
        }

        returnTowardStart() {
            const s = this.smartGetDistance(this.startPosition);
            if (s.length == 0) {
                this.wait();
                return;
            }
            this.direction = randomElement(s);
            this.move(this.direction);
        }

        AIMove() {
            if (!this.isAlive()) {
                return;
            }

            if (this.stat.nature == 'attack') {
                let targets = game.spriteList.filter((sprite)=>{return sprite.team != this.team && sprite.isAlive()});
                if (targets.length == 0) {
                    this.returnTowardStart();
                    return;
                }

                const target = targets.toSorted((sprite1, sprite2)=> dist(this.position, sprite1.position) - dist(this.position, sprite2.position))[0];
                this.turnToward(target.position);
                const d = dist(this.position, target.position);
                const d1 = dist1(this.position, target.position);
                if (d == 1) {
                    this.useMove();
                    return;
                }

                if (d == 0 || d1 >= 9) {
                    this.returnTowardStart();
                    return;
                }
                
                const s = this.smartGetDistance(addCoords(target.position, game.controls[game.opposite[target.direction]]));
                //print(s);
                if (s.length == 0) {
                    this.returnTowardStart();
                    return;
                }
                
                this.direction = randomElement(s);
                this.move(this.direction);
            }

            if (this.stat.nature == 'wander') {
                let targets = game.spriteList.filter((sprite)=>{return sprite.team != this.team && dist1(this.position, sprite.position) < 10 && !game.map.isHidden(sprite.position) && sprite.isAlive()});
                
                if (targets.length == 0) {
                    this.direction = randomElement(['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'])
                    if (this.getTarget()) {
                        this.direction = game.opposite[this.direction];
                    }
                    this.move(this.direction);
                    return;
                }
                const target = targets.toSorted((sprite1, sprite2)=> dist(this.position, sprite1.position) - dist(this.position, sprite2.position))[0];
                this.turnToward(target.position);
                this.stat.nature = 'attack';
                this.wait();
            }

            if (this.stat.nature == 'back and forth') {
                let targets = game.spriteList.filter((sprite)=>{return sprite.team != this.team && dist(this.position, sprite.position) == 1 && !game.map.isHidden(sprite.position) && sprite.isAlive()});
                if (targets.length == 0) {
                    if (this.getTarget()) {
                        this.direction = game.opposite[this.direction];
                    }
                    this.move(this.direction);
                    return;
                }
                this.turnToward(targets[0].position);
                this.stat.nature = 'attack';
                this.useMove();
            }

            if (this.stat.nature == 'follow team') {
                let targets = game.spriteList.filter((sprite) => {return sprite.team == this.team && sprite.isAlive() && sprite.name != this.name && sprite.control == true});
                    
                if (targets.length == 0) {
                    this.wait();
                    return;
                }
                const target = targets.toSorted((sprite1, sprite2)=> dist(this.position, sprite1.position) - dist(this.position, sprite2.position))[0];
                this.turnToward(target.position);
                const d = dist(this.position, target.position);
                const d1 = dist1(this.position, target.position);

                if (d == 1) {
                    this.wait();
                    return;
                }
                    
                if (d == 0 || d1 >= 10) {
                    this.wait();
                    return;
                }
                
                const s = this.smartGetDistance(addCoords(target.position, game.controls[game.opposite[target.direction]]));
                    //print(s);
                if (s.length == 0) {
                    this.wait();
                    return;
                }
                this.direction = randomElement(s);
                this.move(this.direction);                
            }

            if (this.stat.nature == 'wait') {
                this.wait();
            }
        }
    }

    class Map {
        constructor(options) {
            this.name = options.name;
            this.tiles = options.tiles;
            this.sprite = options.mapSprite;
            this.warpZones = options.warpZones;
            if (Object.hasOwn(options, 'randomEncounters')) {
                this.randomEncounters = options.randomEncounters;
            }
            this.tileHeight = 48;
            this.tileWidth = 24;
            this.tileSize = 24;

            if (this.sprite) {
                this.image = new Image();
                this.image.src = `sprites/${this.sprite}.png`;
                this.loaded = false;
                this.image.onload = () => {this.loaded = true};
            }
            this.items = options.items;
            this.itemSprite = options.itemSprite;
            if (this.itemSprite) {
                this.imageItem = new Image();
                this.imageItem.src = `sprites/${this.itemSprite}.png`;
                this.loadedItem = false;
                this.imageItem.onload = () => {this.loadedItem = true};
            }
        }

        deleteItem(itemName, coord) {
            const i = this.items.findIndex((item)=>{return item.name == itemName && coordsEq(coord, item.position)});
            if (i != -1) {
                this.items.splice(i,1);
            }
        }

        spawnItem(itemName, coord) {
            this.items.push({
                name: itemName,
                position: coord
            })
        }

        getItem(coord) {
            let a = this.items.filter((item)=>{return coordsEq(item.position, coord)});
            if (a.length > 0) {
                const picked = a[0].name;
                this.deleteItem(picked, coord);
                return picked;
            } else {
                return 'none';
            }
        }

        inRange(coord) {
            return coord.x >= 0 && coord.y >= 0 && coord.x < this.tiles[0].length && coord.y < this.tiles.length;
        }

        isWall(coord, solidTiles = [6, 7, 8, 9, 10]) {
            if (this.inRange(coord)) {
                return solidTiles.includes(this.tiles[coord.y][coord.x]);
            }
            else {
                return false;
            }
        }

        isHidden(coord, hiddenTiles = [5]) {
            if (this.inRange(coord)) {
                return hiddenTiles.includes(this.tiles[coord.y][coord.x]);
            }
            else {
                return false;
            }
        }

        warp(coord) {
            if (!Object.hasOwn(this.warpZones, `${coord.x},${coord.y}`)) {
                return false;
            }
            const w = this.warpZones[`${coord.x},${coord.y}`];
            if (prompt(`Proceed to ${w.name}? (y/n)`,'y') != 'y') {
                return false;
            }
            document.getElementById('StatBox').innerHTML = '';

            game.loadMap(game.spriteList.filter((sprite)=>{return sprite.team == 0}), w.name, w.spawnLocation);
            return true;
        }

/*         draw(camera) {
            if (!(this.loaded)) {
                ctx.fillStyle = 'white';
                ctx.font = "bold 24px monospace";
                ctx.fillText('Loading...', 5, 25);
            }
            for (let i = 0; i < this.tiles.length; i++) {
                for (let j = 0; j < this.tiles[i].length; j++) {
                    const coords = screenCoords({x: j, y: i});
                    const col = this.tiles[i][j] % 6;
                    const row = Math.floor(this.tiles[i][j] / 6);
                    if (this.sprite && this.loaded && dist1(camera, {x: j, y: i}) < 6) {
                        ctx.drawImage(this.image, 24 * col, 10, 24, 48, coords.x, coords.y - 24, 24, 48);
                    }
                    else {
                        if (this.tiles[i][j] && dist1(camera, {x: j, y: i}) < 6) {
                            ctx.fillStyle = this.color;
                            ctx.fillRect(coords.x, coords.y, Math.floor(canvas.width / w), Math.floor(canvas.height / h));
                        }
                    }
                }
            }
            for (const item of this.items) {
                const coords = screenCoords(item.position);

                if (this.itemSprite && this.loadedItem && dist1(camera, item.position) < 6) {
                    const it = itemList[item.name];
                    let i = 0;
                    if (Object.hasOwn(it, 'spriteIndex')) {
                        i = it.spriteIndex;
                    }
                    ctx.drawImage(this.imageItem, this.tileSize * i, 0, this.tileSize, this.tileSize, coords.x, coords.y, Math.floor(canvas.width / w), Math.floor(canvas.height / h));
                } else {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(coords.x, coords.y, Math.floor(canvas.width / w / 2), Math.floor(canvas.height / h / 2));
                }
            }
        } */
    }

    document.addEventListener('keydown', e => {
        if (['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown', 'Space', 'KeyZ', 'KeyX', 'KeyC', 'KeyV','KeyH','KeyP','Digit1','Digit2','Digit3','Digit4'].includes(e.code)) {
            game.actionQueue.push(e.code);
            game.doStuff();
        }
        if (['KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
            const aliasKey = {
                'KeyW': 'ArrowUp',
                'KeyA': 'ArrowLeft',
                'KeyS': 'ArrowDown',
                'KeyD': 'ArrowRight'
            }
            game.actionQueue.push(aliasKey[e.code]);
            game.doStuff();
        }
    });
    
    for (const key of ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown', 'Space', 'KeyZ', 'KeyX', 'KeyC','KeyV']) {
        document.getElementById(key).addEventListener('click', (e) => {
            game.actionQueue.push(key);
            game.doStuff();
        })
    }

    const game = {

        actionQueue: [],

        moveUsed: false,

        loaded: false,

        you: false,

        map: false,

        spriteList: false,

        controlAll: false,

        iter: 0,

        controls: {
            'ArrowRight': {x: 1, y: 0},
            'ArrowLeft': {x: -1, y: 0},
            'ArrowUp': {x: 0, y: -1},
            'ArrowDown': {x: 0, y: 1},
        },

        arrowNumber: {
            'ArrowRight': 1,
            'ArrowLeft': 3,
            'ArrowUp': 0,
            'ArrowDown': 2,
        },
        opposite: {
            'ArrowRight': 'ArrowLeft',
            'ArrowLeft': 'ArrowRight',
            'ArrowUp': 'ArrowDown',
            'ArrowDown': 'ArrowUp',
        },

        toggleControl: function() {
            this.controlAll = !this.controlAll;
            alert(`Now controlling ${this.controlAll ? 'whole team' : 'current character'}!`)
            for (let i = 0; i < this.spriteList.length; i++) {
                const sprite = this.spriteList[i];
                if (sprite.team == 0 && i != this.iter) {
                    sprite.control = this.controlAll;
                }
            }
        },

        spawnEntity: function(data) {
            const d = deepCopy(data);
            this.spriteList.push(
                new Entity({
                    nickname: d.nickname,
                    stat: deepCopy(speciesList[d.speciesName].stat),
                    position: d.position,
                    options: d.options
                })
            )
        },

        spawnRandomEncounter: function() {
            if (this.spriteList.length > 10) {
                return false;
            }
            if (Object.hasOwn(this.map, 'randomEncounters')) {
                const p = randomElement(this.map.randomEncounters.spawnLocations.filter((p)=>{return dist1(this.you.position, p) > 5}));
                const s = randomElement(this.map.randomEncounters.species);

                this.spawnEntity({
                    nickname: s[0].toUpperCase() + s.slice(1),
                    speciesName: s,
                    position: p,
                    options: {
                        direction: 'ArrowRight',
                        item: 'none',
                        team: 1,
                        control: false,
                        moveset: speciesList[s].stat.defaultMoves
                    }
                })
            }
        },

        loadMap: function(s, m, spawnLocation = false) {
            this.map = new Map(deepCopy(mapData[m]));
            this.spriteList = s;
            //print(this.spriteList);
            this.you = this.spriteList[0];
            this.loaded = true;

            if (spawnLocation) {
                for (const sprite of this.spriteList) {
                    if (sprite.team == 0) {
                        sprite.position = spawnLocation;
                    }
                }
            }

            for (sprite of this.spriteList) {
                if (sprite.loaded) {
                    sprite.generateHPBar();
                }
            }

            if (Object.hasOwn(mapData[m], 'entitiesOnSpawn')) {
                for (data of mapData[m].entitiesOnSpawn) {
                    this.spawnEntity(data);
                }
            }

            this.iter = 0;
            setTimeout(()=>{
                game.doStuff();
            }, 500);
        },

        doStuff: function() {
            if (this.spriteList.filter((sprite) => {return sprite.control}).length == 0) {
                return false;
            }
            const sprite = this.spriteList[this.iter];
            
            if (!sprite.isAlive()) {
                sprite.dropItem();
                this.spriteList.splice(this.iter, 1);
                this.iter = this.iter % this.spriteList.length;
                this.drawEverything(this.you.position);
                print(`${sprite.name} fainted.`);
                setTimeout(()=>{game.drawEverything(game.you.position);}, 0);
                if (this.spriteList.filter((sprite) => {return sprite.control}).length == 0) {
                    alert('You Died. Restart?');
                    document.getElementById('StatBox').innerHTML = '';
                    game.loadMap(getRestartSpriteList(), 'doors');
                    this.iter = 0;
                    this.actionQueue = [];
                }
                return false;
            }

            sprite.actionCounter--;

            if (sprite.actionCounter > 0) {
                this.iter = (this.iter + 1) % this.spriteList.length;
                setTimeout(()=>{game.doStuff();}, 0);
                return false;
            }

            if (!sprite.control) {
                sprite.AIMove();
                this.drawEverything(this.you.position);
                if (sprite.actionCounter > 0) {
                    sprite.endTurn();
                    this.iter = (this.iter + 1) % this.spriteList.length;
                }
                setTimeout(()=>{game.doStuff();}, dist1(sprite.position, this.you.position) < 6 ? 50 : 0);
                return true;
            }

            this.you = sprite;
            if (this.actionQueue.length == 0) {
                sprite.actionCounter++;
                this.drawEverything(this.you.position);
                return false;
            }

            const code = this.actionQueue[0];
            if (['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'].includes(code)) {
                this.you.move(code);
            }
            if (code == 'Space') {
                this.you.useMove();
                //this.you.attack(this.you.getTarget(), 5);
            }
            if (['Digit1', 'Digit2', 'Digit3', 'Digit4'].includes(code)) {
                const n = {'Digit1':0, 'Digit2':1, 'Digit3':2, 'Digit4':3}
                this.you.useMove(n[code]);
            }
            if (code == 'KeyH') {
                this.you.heal(1);
            }
            if (code == 'KeyC') {
                this.you.useItem();
            }
            if (code == 'KeyX') {
                this.you.pickUpItem();
            }
            if (code == 'KeyZ') {
                this.you.dropItem();
            }
            if (code == 'KeyV') {
                this.you.wait();
            }
            if (code == 'KeyP') {
                this.toggleControl();
            }
            this.actionQueue.splice(0,1);

            if (sprite.actionCounter <= 0) {
                sprite.actionCounter++;
                this.drawEverything(this.you.position);
                setTimeout(()=>{game.doStuff();}, 500);
                return false;
            }
            
            sprite.endTurn();
            this.iter = (this.iter + 1) % this.spriteList.length;
            if (Math.floor(Math.random() * 5) == 0) {this.spawnRandomEncounter();}
            this.drawEverything(this.you.position);
            setTimeout(()=>{game.doStuff();}, 500);
            return true;          
        },

        drawEverything: function(camera) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            //this.map.draw(camera);
            if (!(this.map.loaded)) {
                ctx.fillStyle = 'white';
                ctx.font = "bold 24px monospace";
                ctx.fillText('Loading...', 5, 25);
            }
            for (let i = 0; i < this.map.tiles.length; i++) {
                for (let j = 0; j < this.map.tiles[i].length; j++) {
                    const coords = screenCoords({x: j, y: i});
                    const col = this.map.tiles[i][j] % 6;
                    const row = Math.floor(this.map.tiles[i][j] / 6);
                    if (this.map.sprite && this.map.loaded && dist1(camera, {x: j, y: i}) < 6) {
                        ctx.drawImage(this.map.image, 24 * col, 48 * row, 24, 48, coords.x, coords.y - 24, 24, 48);
                    }
                }

                this.map.items.filter((item)=>{return item.position.y == i}).forEach((item) => {
                    const coords = screenCoords(item.position);

                    if (this.map.itemSprite && this.map.loadedItem && dist1(camera, item.position) < 6) {
                        const it = itemList[item.name];
                        let i = 0;
                        if (Object.hasOwn(it, 'spriteIndex')) {
                            i = it.spriteIndex;
                        }
                        ctx.drawImage(this.map.imageItem, 24 * i, 0, 24, 24, coords.x, coords.y, 24, 24);
                    } else {
                        ctx.fillStyle = 'red';
                        ctx.fillRect(coords.x, coords.y, Math.floor(canvas.width / w / 2), Math.floor(canvas.height / h / 2));
                    }
                })

                this.spriteList.filter((sprite)=>{return sprite.position.y == i;}).toReversed().forEach(sprite => {
                    if (sprite.isAlive() && !this.map.isHidden(sprite.position)) {
                        sprite.draw();
                    };
                    sprite.printTo(dist1(sprite.position, camera) > 5 || !sprite.isAlive());
                });
                
            }

            if (this.moveUsed) {
                moveAnimation.draw(this.moveUsed.user, this.moveUsed.move, {ctx: ctx});
                this.moveUsed = false;
            }

            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            ctx2.drawImage(canvas, 0, 0, canvas2.width, canvas2.height);
        }
    }
</script>
<script src = "map.js"></script>
<script>
    function getRestartSpriteList() {
        return [
            new Entity({
                nickname: 'Human',
                stat: {
                    maxHP: 100,
                    atk: 80,
                    def: 100,
                    spa: 80,
                    spd: 100,
                    cooldown: 10,
                    nature: 'follow team',
                    types: ['normal'],
                    color:'black',
                    sprite: 'human',
                    size: 24
                },
                position: {
                    x: 25, 
                    y: 17
                },
                options: {
                    direction: 'ArrowRight',
                    item: 'none',
                    team: 0,
                    control: true,
                    moveset: [
                        'moveTackle'
                    ]
                }
            }),

            new Entity({
                nickname: 'Random Noob',
                stat: {
                    maxHP: 10,
                    atk: 10,
                    def: 10,
                    spa: 10,
                    spd: 10,
                    cooldown: 12,
                    nature: 'follow team',
                    types: ['normal'],
                    color:'black',
                    sprite: 'human2',
                    size: 24
                },
                position: {
                    x: 53,
                    y: 17
                },
                options: {
                    direction: 'ArrowRight',
                    item: 'none',
                    team: 0,
                    control: false,
                    moveset: [
                        'moveTackle',
                        'moveKarateChop',
                        'moveSwordsDance',
                        'moveQuickAttack'
                    ]
                }
            })
        ];
    }
    
    //alert('Escape the hotel. Beware the entities!');
    resize();
    game.loadMap(getRestartSpriteList(), 'doors');
    //setTimeout(game.doStuff, 500);

    function secretTest() {
        
        const coord = game.you.position;
        game.spriteList[0] = new Entity({
            nickname: 'Sanctuavia',
            stat: {
                maxHP: 85,
                atk: 70,
                def: 85,
                spa: 120,
                spd: 95,
                cooldown: 8,
                nature: 'attack',
                types: ['flying'],
                color:'black',
                sprite: 'pokemon/sanctuavia',
                size: 32
            },
            position: {
                x: 25, 
                y: 17
            },
            options: {
                direction: 'ArrowRight',
                item: 'none',
                team: 0,
                control: true,
                moveset: [
                    'moveAeropulse',
                    'moveIceBeam',
                    'moveEarthPower',
                    'moveRoost'
                ]
            }
        });
        game.you = game.spriteList[0];
        game.you.position = coord;
        game.map.tiles[17][23] = 4;
        setTimeout(()=>{game.drawEverything(game.you.position);}, 500);
    }
    //secretTest();
</script>

</html>